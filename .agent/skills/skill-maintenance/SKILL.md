---
name: skill-maintenance
description: 识别场景并判断何时需要更新或变更已存在的 skills
---

# Skill 维护与更新判断规范

## 概述

本 skill 指导如何识别需要更新 skill 的场景，提供判断标准和更新决策流程，确保 skills 系统始终保持最新和准确。

### 适用场景

- 项目技术栈升级
- 发现更好的实践方式
- skill 内容与实际代码不一致
- 收到使用反馈
- 定期审查 skills 质量

## 更新触发场景

### 场景分类矩阵

| 触发场景           | 严重程度 | 建议行动   | 优先级 |
| ------------------ | -------- | ---------- | ------ |
| 代码规范已变更     | 🔴 高    | 立即更新   | P0     |
| skill 示例代码失效 | 🔴 高    | 立即更新   | P0     |
| 项目架构重构       | 🟡 中    | 尽快更新   | P1     |
| 依赖版本升级       | 🟡 中    | 评估后更新 | P1     |
| 发现更优实践       | 🟢 低    | 计划更新   | P2     |
| 内容表述优化       | 🟢 低    | 批量优化   | P3     |

### 1. 代码规范变更

**触发条件：**

- 项目代码风格指南更新（`docs/contributing/code-style.md`）
- 新增编码规范或约束
- 废弃某些旧的实践方式

**判断标准：**

```
如果 skill 中的示例代码或指导与新规范冲突：
  → 必须立即更新
否则：
  → 可延后处理
```

**示例：**

```markdown
旧规范：使用 `errors.New()` 创建错误
新规范：统一使用 `pkg/errors` 包的错误码系统

受影响的 skills：

- service-development
- handler-development
- repository-development
- error-handling

更新操作：

1. 更新所有涉及错误处理的示例代码
2. 添加新的错误码使用说明
3. 标记旧方式为已废弃
```

### 2. 项目架构调整

**触发条件：**

- 目录结构重组
- 模块拆分或合并
- 依赖注入方式改变
- 新增或移除核心组件

**判断标准：**

检查以下文件的变更：

- `internal/app/` - 应用初始化逻辑
- `internal/types/` - 核心接口定义
- `pkg/` - 基础组件库
- `docs/architecture/` - 架构文档

**决策树：**

```
架构变更是否影响 skill 中的开发流程？
├─ 是 → 需要更新
│   ├─ 影响范围 > 3个skill → 优先级 P1
│   └─ 影响范围 ≤ 3个skill → 优先级 P2
└─ 否 → 无需更新
```

**示例：**

```markdown
架构变更：从 Options 模式改为 SetXXX 延迟注入

受影响的 skills：

- service-development（依赖注入方式变更）
- middleware-development（中间件初始化变更）
- pkg-development（接口设计模式变更）

更新检查点：
□ 构造函数签名是否变更
□ 依赖注入方式是否调整
□ 示例代码是否需要重写
□ 最佳实践部分是否需要补充
```

### 3. 依赖版本升级

**触发条件：**

- 主要框架版本升级（如 Gin v1 → v2）
- 核心库 API 变更
- 新增重要第三方库

**评估流程：**

```
1. 检查 CHANGELOG
   ├─ 是否有 Breaking Changes？
   │   ├─ 是 → 必须更新 skill
   │   └─ 否 → 继续评估
   └─ 是否有新增推荐用法？
       ├─ 是 → 建议更新 skill
       └─ 否 → 无需更新
```

**检查清单：**

```markdown
依赖升级影响评估

基础信息：

- 包名: ****\_\_\_****
- 旧版本: ****\_\_\_****
- 新版本: ****\_\_\_****

影响分析：

- [ ] API 签名变更
- [ ] 新增推荐功能
- [ ] 废弃旧方法
- [ ] 配置格式变更
- [ ] 性能优化建议

关联 skills：

- [ ] skill-1: ****\_\_\_****
- [ ] skill-2: ****\_\_\_****

更新决策：

- [ ] 必须更新（Breaking Changes）
- [ ] 建议更新（新增最佳实践）
- [ ] 无需更新（向后兼容且无新特性）
```

### 4. 实际代码与 Skill 不一致

**识别方法：**

**方法 1：代码审查发现**

```bash
# 审查最近的代码变更
git log --since="1 month ago" --name-only --pretty=format: | sort -u

# 对比 skill 中的示例
```

**方法 2：使用反馈**

- 开发者报告 skill 指导与实际不符
- 新人按 skill 操作遇到问题
- CI/CD 检查发现不一致

**方法 3：自动化检测（可选）**

```bash
# 示例：检查 skill 中引用的文件路径是否存在
#!/bin/bash
for skill in .agent/skills/*/SKILL.md; do
  echo "Checking $skill..."
  grep -oP '(?<=`)[^`]+\.go(?=`)' "$skill" | while read file; do
    if [ ! -f "$file" ]; then
      echo "  ⚠️  File not found: $file"
    fi
  done
done
```

**更新优先级：**

```
不一致严重程度评分（每项1分）：
□ skill 中的代码无法运行（+3分）
□ 文件路径已变更（+2分）
□ 接口签名已改变（+2分）
□ 最佳实践已过时（+1分）
□ 仅措辞不准确（+0.5分）

总分 ≥ 3分 → P0 立即修复
总分 2-2.5分 → P1 本周内修复
总分 1-1.5分 → P2 本月内修复
总分 < 1分 → P3 计划优化
```

### 5. 发现更优实践

**判断标准：**

新实践应满足以下条件才值得更新 skill：

- ✅ **已验证**：在项目中实际使用并证明有效
- ✅ **可复用**：适用于多个类似场景
- ✅ **显著改进**：相比旧方式有明显优势
- ✅ **无副作用**：不引入新问题或技术债

**评估表：**

| 评估维度          | 旧实践得分 | 新实践得分 | 改进幅度 |
| ----------------- | ---------- | ---------- | -------- |
| 代码简洁性（1-5） | \_\_\_     | \_\_\_     | \_\_\_   |
| 性能（1-5）       | \_\_\_     | \_\_\_     | \_\_\_   |
| 可维护性（1-5）   | \_\_\_     | \_\_\_     | \_\_\_   |
| 易理解性（1-5）   | \_\_\_     | \_\_\_     | \_\_\_   |
| **总分**          | \_\_\_     | \_\_\_     | \_\_\_   |

```
如果 改进幅度总分 ≥ 5：
  → 值得更新 skill
否则：
  → 保持现状或作为补充说明
```

### 6. 用户反馈

**反馈来源：**

- 开发者提出的疑问
- Code Review 中的讨论
- 新人入职时的困惑
- 项目复盘会议记录

**处理流程：**

```
收到反馈
  ↓
是否有效反馈（真实问题）？
  ├─ 否 → 归档
  └─ 是 → 记录到反馈日志
      ↓
分析根因
  ├─ skill 内容错误 → P0 立即修复
  ├─ skill 内容不完整 → P1 补充说明
  ├─ skill 示例不够清晰 → P2 优化示例
  └─ skill 无问题（用户误解）→ 考虑增加 FAQ
```

**反馈日志模板：**

```markdown
## 反馈记录

### 反馈 #001

- **日期**: 2026-01-19
- **来源**: 开发者反馈
- **相关 Skill**: service-development
- **问题描述**: 依赖注入部分示例代码缺少错误处理
- **严重程度**: 中
- **处理状态**: 待处理
- **计划更新**: 补充错误处理示例

### 反馈 #002

...
```

## 定期审查机制

### 审查周期

| 审查类型 | 频率   | 范围              | 负责人      |
| -------- | ------ | ----------------- | ----------- |
| 快速检查 | 每周   | 近期变更的 skills | 开发 Leader |
| 全面审查 | 每月   | 所有 skills       | 技术团队    |
| 深度优化 | 每季度 | 核心 skills       | 架构师      |

### 每周快速检查

**检查内容：**

```bash
# 1. 检查本周代码变更影响的 skills
git diff --name-only HEAD~7 HEAD | grep -E "internal|pkg" > changed_files.txt

# 2. 查找可能受影响的 skills
# （手动审查或使用脚本）

# 3. 验证示例代码
# （运行 skill 中的示例，确保可用）
```

### 每月全面审查

**审查清单：**

```markdown
## Skills 月度审查

### 基础检查

- [ ] 所有 skill 的 YAML frontmatter 格式正确
- [ ] 所有引用的文件路径有效
- [ ] 所有示例代码可以运行
- [ ] 所有链接可以访问

### 内容检查

- [ ] 内容与当前代码库一致
- [ ] 最佳实践仍然适用
- [ ] 没有过时的技术栈引用
- [ ] 检查清单完整且准确

### 质量检查

- [ ] 语言表达清晰准确
- [ ] 代码格式规范统一
- [ ] 示例代码有足够注释
- [ ] 结构层次清晰

### 覆盖度检查

- [ ] 是否有新的开发场景未覆盖
- [ ] 是否需要新增 skill
- [ ] 是否有 skill 已不再需要
```

### 季度深度优化

**优化方向：**

1. **结构优化**
   - 合并相似内容的 skills
   - 拆分过于复杂的 skills
   - 调整 skill 之间的引用关系

2. **内容优化**
   - 更新过时的示例
   - 补充新的最佳实践
   - 增加常见问题解答

3. **形式优化**
   - 统一术语和表达
   - 改进代码示例的注释
   - 优化排版和格式

## 更新决策流程

### 决策树

```
发现潜在更新需求
  ↓
评估影响范围
  ├─ 影响核心开发流程？
  │   ├─ 是 → P0/P1 高优先级
  │   └─ 否 → 继续评估
  ↓
评估紧迫性
  ├─ 当前 skill 是否会误导？
  │   ├─ 是 → P0 立即更新
  │   └─ 否 → 继续评估
  ↓
评估改进价值
  ├─ 更新后能显著提升效率？
  │   ├─ 是 → P1/P2 计划更新
  │   └─ 否 → P3 延后或不更新
```

### 更新成本评估

**估算更新工作量：**

| 更新类型          | 预计时间 | 示例         |
| ----------------- | -------- | ------------ |
| 修正错误路径/命令 | 10分钟   | 文件路径变更 |
| 更新单个示例代码  | 30分钟   | API 签名调整 |
| 重写整个章节      | 1-2小时  | 架构模式变更 |
| 全面重构 skill    | 3-4小时  | 技术栈升级   |

**ROI 计算：**

```
更新价值分 = (受影响开发者数量 × 每次使用节省时间 × 预计使用次数)
更新成本分 = 更新所需时间

如果 更新价值分 / 更新成本分 > 5：
  → 高优先级更新
如果 更新价值分 / 更新成本分 > 2：
  → 适时更新
否则：
  → 低优先级或不更新
```

## 更新操作指南

### 更新流程

```
1. 创建更新计划
   ├─ 明确更新范围
   ├─ 列出具体变更点
   └─ 预估工作量

2. 执行更新
   ├─ 备份原 skill（可选）
   ├─ 修改内容
   └─ 验证示例代码

3. 质量检查
   ├─ 自查检查清单
   ├─ 运行示例代码
   └─ 同行审阅（重要更新）

4. 记录变更
   ├─ 在 skill 顶部添加更新记录（可选）
   └─ 在变更日志中记录

5. 通知相关人员
   ├─ 重要更新：通知全部开发者
   └─ 一般更新：在周会中提及
```

### 更新记录格式（可选）

如果 skill 更新频繁，可在文件顶部添加更新记录：

```markdown
---
name: service-development
description: 在 internal/service/ 目录下创建新的业务服务
---

> **更新记录**
>
> - 2026-01-19: 调整依赖注入方式，从 Options 改为 SetXXX 模式
> - 2026-01-15: 补充错误处理示例
> - 2026-01-10: 更新缓存集成说明

# 服务开发规范

...
```

### 批量更新策略

当多个 skills 需要同类更新时：

```
1. 识别更新模式
   示例：所有 skills 都需要更新错误处理方式

2. 创建更新模板
   示例：标准的错误处理代码块

3. 批量应用
   ├─ 使用脚本辅助（如果可行）
   └─ 或逐个手动更新

4. 批量验证
   └─ 确保所有更新一致且正确
```

## 版本控制（可选）

### 是否需要版本号

**适用场景：**

- skills 系统非常成熟稳定
- 有多人协作维护
- 需要追踪重大变更

**版本号格式：**

```
v{Major}.{Minor}.{Patch}

Major: 重大架构变更，不兼容旧版本
Minor: 功能新增或重要更新
Patch: 错误修正或小幅优化
```

**示例：**

```markdown
---
name: service-development
description: 在 internal/service/ 目录下创建新的业务服务
version: 2.1.0
---
```

### 不使用版本号

**大多数情况推荐：**

- 直接更新 skill 内容
- 通过 Git 历史追踪变更
- 保持 skills 简单易维护

## 工具辅助

### 一致性检查脚本

```bash
#!/bin/bash
# check-skills-consistency.sh

echo "🔍 检查 Skills 一致性..."

# 1. 检查引用的文件是否存在
echo "1. 检查文件路径..."
for skill in .agent/skills/*/SKILL.md; do
  grep -oP '(?<=`)[^`]+\.(go|md)(?=`)' "$skill" | while read file; do
    if [ ! -f "$file" ]; then
      echo "  ⚠️  [$skill] 引用的文件不存在: $file"
    fi
  done
done

# 2. 检查 YAML frontmatter
echo "2. 检查 YAML frontmatter..."
for skill in .agent/skills/*/SKILL.md; do
  if ! head -5 "$skill" | grep -q "^name:"; then
    echo "  ⚠️  [$skill] 缺少 name 字段"
  fi
  if ! head -5 "$skill" | grep -q "^description:"; then
    echo "  ⚠️  [$skill] 缺少 description 字段"
  fi
done

# 3. 检查是否有过时的包引用
echo "3. 检查过时的包引用..."
DEPRECATED_PACKAGES=("github.com/pkg/errors")
for skill in .agent/skills/*/SKILL.md; do
  for pkg in "${DEPRECATED_PACKAGES[@]}"; do
    if grep -q "$pkg" "$skill"; then
      echo "  ⚠️  [$skill] 使用了过时的包: $pkg"
    fi
  done
done

echo "✅ 检查完成"
```

### 更新提醒配置

```yaml
# .agent/skills-maintenance.yaml（可选配置文件）

# 审查提醒
reviews:
  weekly: true
  monthly: true
  quarterly: true

# 自动检查
auto_checks:
  - file_existence
  - yaml_format
  - deprecated_patterns

# 关注的代码路径
watched_paths:
  - internal/
  - pkg/
  - docs/architecture/

# 当这些文件变更时，触发 skill 审查提醒
triggers:
  - docs/contributing/code-style.md
  - internal/types/interfaces.go
  - go.mod
```

## 最佳实践

### 1. 预防性维护

**主动识别更新需求：**

- ✅ 代码变更时立即思考是否影响 skills
- ✅ 新技术引入时同步创建/更新 skill
- ✅ 定期审查而不是等问题出现

### 2. 渐进式更新

**避免一次性大规模重构：**

- ✅ 优先更新最常用的 skills
- ✅ 分批次逐步改进
- ✅ 每次更新后收集反馈

### 3. 保持简洁

**避免过度设计：**

- ✅ 不需要的 skill 及时删除
- ✅ 相似内容考虑合并
- ✅ 说明简洁明了，避免冗长

### 4. 文档同步

**确保多处文档一致：**

```
更新 skill 时，同步检查：
  ├─ docs/architecture/ - 架构文档
  ├─ docs/contributing/ - 贡献指南
  ├─ README.md - 项目说明
  └─ pkg/*/README.md - 组件文档
```

### 5. 用户视角

**从使用者角度评估：**

- ✅ 新手能否理解
- ✅ 示例是否足够清晰
- ✅ 步骤是否容易遵循

## 检查清单

### 更新决策检查

- [ ] 已识别更新触发场景
- [ ] 已评估影响范围和优先级
- [ ] 已估算更新成本和价值
- [ ] 已确定是否需要更新

### 更新执行检查

- [ ] 已创建更新计划
- [ ] 已更新相关内容
- [ ] 所有示例代码已验证
- [ ] 已通过检查清单自查
- [ ] 已记录变更（如需要）

### 更新后验证

- [ ] skill 内容与代码库一致
- [ ] 示例代码可运行
- [ ] 文件路径引用正确
- [ ] 相关文档已同步更新
- [ ] 已通知相关人员（如需要）
