# 中间件指南

本文档详细说明了 Rei0721 项目中间件的设计、实现和使用方法。

## 中间件概述

中间件是处理 HTTP 请求的横切关注点，在请求到达处理器之前和响应返回之前执行。

### 中间件执行顺序

```
请求进入
   ↓
TraceID 中间件 (生成/提取 TraceID)
   ↓
Logger 中间件 (记录请求信息)
   ↓
Recovery 中间件 (捕获 panic)
   ↓
处理器 (业务逻辑)
   ↓
Recovery 中间件 (后置处理)
   ↓
Logger 中间件 (记录响应信息)
   ↓
TraceID 中间件 (后置处理)
   ↓
响应返回
```

## TraceID 中间件\n\n### 功能\n\n- 生成或提取 X-Request-ID 头\n- 将 TraceID 注入到 context\n- 传递给后续所有处理\n\n### 配置\n\n```go\ntype TraceIDConfig struct {\n    Enabled    bool\n    HeaderName string  // 默认: X-Request-ID\n}\n\n// 使用\ncfg := middleware.TraceIDConfig{\n    Enabled:    true,\n    HeaderName: \"X-Request-ID\",\n}\nrouter.Use(middleware.TraceID(cfg))\n```\n\n### 实现\n\n```go\nfunc TraceID(cfg TraceIDConfig) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        if !cfg.Enabled {\n            c.Next()\n            return\n        }\n        \n        // 从请求头获取或生成 TraceID\n        traceID := c.GetHeader(cfg.HeaderName)\n        if traceID == \"\" {\n            traceID = generateTraceID()\n        }\n        \n        // 注入到 context\n        ctx := context.WithValue(c.Request.Context(), \"traceID\", traceID)\n        c.Request = c.Request.WithContext(ctx)\n        \n        // 设置响应头\n        c.Header(cfg.HeaderName, traceID)\n        \n        c.Next()\n    }\n}\n```\n\n### 使用 TraceID\n\n```go\n// 在处理器中获取 TraceID\nfunc (h *UserHandler) Register(c *gin.Context) {\n    traceID := c.GetString(\"traceID\")\n    \n    // 传递给服务层\n    resp, err := h.service.Register(c.Request.Context(), &req)\n}\n\n// 在日志中包含 TraceID\nlogger.Info(\"user registered\",\n    \"traceID\", traceID,\n    \"userId\", user.ID,\n)\n```\n\n## Logger 中间件\n\n### 功能\n\n- 记录请求方法、路径、状态码\n- 记录响应时间\n- 支持跳过路径配置\n\n### 配置\n\n```go\ntype LoggerConfig struct {\n    Enabled   bool\n    SkipPaths []string  // 跳过的路径\n}\n\n// 使用\ncfg := middleware.LoggerConfig{\n    Enabled: true,\n    SkipPaths: []string{\"/health\", \"/metrics\"},\n}\nrouter.Use(middleware.Logger(cfg, logger))\n```\n\n### 实现\n\n```go\nfunc Logger(cfg LoggerConfig, log logger.Logger) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        if !cfg.Enabled {\n            c.Next()\n            return\n        }\n        \n        // 检查是否跳过\n        if shouldSkip(c.Request.URL.Path, cfg.SkipPaths) {\n            c.Next()\n            return\n        }\n        \n        // 记录请求信息\n        startTime := time.Now()\n        \n        c.Next()\n        \n        // 记录响应信息\n        duration := time.Since(startTime)\n        log.Info(\"request processed\",\n            \"method\", c.Request.Method,\n            \"path\", c.Request.URL.Path,\n            \"status\", c.Writer.Status(),\n            \"duration\", duration.String(),\n            \"traceID\", c.GetString(\"traceID\"),\n        )\n    }\n}\n```\n\n### 日志输出示例\n\n```json\n{\n  \"level\": \"info\",\n  \"ts\": 1735475400.123,\n  \"msg\": \"request processed\",\n  \"method\": \"POST\",\n  \"path\": \"/api/v1/users/register\",\n  \"status\": 200,\n  \"duration\": \"45.123ms\",\n  \"traceID\": \"abc123def456\"\n}\n```\n\n## Recovery 中间件\n\n### 功能\n\n- 捕获 panic\n- 返回 500 错误\n- 包含 TraceID\n- 记录错误堆栈\n\n### 配置\n\n```go\ntype RecoveryConfig struct {\n    Enabled bool\n}\n\n// 使用\ncfg := middleware.RecoveryConfig{\n    Enabled: true,\n}\nrouter.Use(middleware.Recovery(cfg, logger))\n```\n\n### 实现\n\n```go\nfunc Recovery(cfg RecoveryConfig, log logger.Logger) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        if !cfg.Enabled {\n            c.Next()\n            return\n        }\n        \n        defer func() {\n            if err := recover(); err != nil {\n                // 记录错误\n                log.Error(\"panic recovered\",\n                    \"error\", err,\n                    \"stack\", debug.Stack(),\n                    \"traceID\", c.GetString(\"traceID\"),\n                )\n                \n                // 返回错误响应\n                c.JSON(http.StatusInternalServerError, result.ErrorWithTrace(\n                    errors.ErrInternalServer,\n                    \"internal server error\",\n                    c.GetString(\"traceID\"),\n                ))\n            }\n        }()\n        \n        c.Next()\n    }\n}\n```\n\n### 错误响应示例\n\n```json\n{\n  \"code\": 5000,\n  \"message\": \"internal server error\",\n  \"traceId\": \"abc123def456\",\n  \"serverTime\": 1735475400\n}\n```\n\n## 自定义中间件\n\n### 创建中间件\n\n```go\n// 认证中间件示例\nfunc Auth(authService AuthService) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // 获取 token\n        token := c.GetHeader(\"Authorization\")\n        if token == \"\" {\n            c.JSON(http.StatusUnauthorized, result.Error(\n                errors.ErrUnauthorized,\n                \"missing authorization header\",\n            ))\n            c.Abort()\n            return\n        }\n        \n        // 验证 token\n        user, err := authService.ValidateToken(token)\n        if err != nil {\n            c.JSON(http.StatusUnauthorized, result.Error(\n                errors.ErrInvalidToken,\n                \"invalid token\",\n            ))\n            c.Abort()\n            return\n        }\n        \n        // 将用户信息存储在 context\n        c.Set(\"user\", user)\n        c.Next()\n    }\n}\n```\n\n### 注册中间件\n\n```go\n// 全局中间件\nrouter.Use(Auth(authService))\n\n// 路由组中间件\nv1 := router.Group(\"/api/v1\")\nv1.Use(Auth(authService))\n{\n    v1.POST(\"/users\", handler.CreateUser)\n}\n\n// 单个路由中间件\nrouter.POST(\"/api/v1/users\", Auth(authService), handler.CreateUser)\n```\n\n## 中间件最佳实践\n\n### 1. 中间件顺序很重要\n\n```go\n// ✅ 好 - 正确的顺序\nrouter.Use(middleware.TraceID(cfg))      // 第一个\nrouter.Use(middleware.Logger(cfg, log))  // 第二个\nrouter.Use(middleware.Recovery(cfg, log))// 第三个\n\n// ❌ 不好 - 错误的顺序\nrouter.Use(middleware.Recovery(cfg, log))\nrouter.Use(middleware.Logger(cfg, log))\nrouter.Use(middleware.TraceID(cfg))\n```\n\n### 2. 使用 c.Abort() 停止处理\n\n```go\n// ✅ 好 - 认证失败时停止\nif !authenticated {\n    c.JSON(http.StatusUnauthorized, result.Error(...))\n    c.Abort()  // 停止处理\n    return\n}\n\n// ❌ 不好 - 继续处理\nif !authenticated {\n    c.JSON(http.StatusUnauthorized, result.Error(...))\n    // 没有 Abort，继续处理\n}\n```\n\n### 3. 使用 c.Set/c.Get 传递数据\n\n```go\n// ✅ 好 - 使用 context\nfunc Auth(c *gin.Context) {\n    c.Set(\"user\", user)\n    c.Next()\n}\n\nfunc Handler(c *gin.Context) {\n    user := c.MustGet(\"user\").(*User)\n}\n\n// ❌ 不好 - 使用全局变量\nvar currentUser *User\n\nfunc Auth(c *gin.Context) {\n    currentUser = user\n}\n```\n\n### 4. 记录关键信息\n\n```go\n// ✅ 好 - 记录关键信息\nlog.Info(\"request processed\",\n    \"method\", c.Request.Method,\n    \"path\", c.Request.URL.Path,\n    \"status\", c.Writer.Status(),\n    \"duration\", duration,\n    \"traceID\", traceID,\n)\n\n// ❌ 不好 - 记录过多信息\nlog.Info(\"request\", \"request\", c.Request)\n```\n\n### 5. 处理 panic\n\n```go\n// ✅ 好 - 捕获并处理 panic\ndefer func() {\n    if err := recover(); err != nil {\n        log.Error(\"panic\", \"error\", err)\n        c.JSON(http.StatusInternalServerError, result.Error(...))\n    }\n}()\n\n// ❌ 不好 - 让 panic 传播\n// 没有 defer 和 recover\n```\n\n## 中间件配置\n\n### 默认配置\n\n```go\nfunc DefaultMiddlewareConfig() MiddlewareConfig {\n    return MiddlewareConfig{\n        Recovery: RecoveryConfig{\n            Enabled: true,\n        },\n        Logger: LoggerConfig{\n            Enabled: true,\n            SkipPaths: []string{\n                \"/health\",\n                \"/metrics\",\n            },\n        },\n        TraceID: TraceIDConfig{\n            Enabled:    true,\n            HeaderName: \"X-Request-ID\",\n        },\n    }\n}\n```\n\n### 自定义配置\n\n```go\ncfg := middleware.MiddlewareConfig{\n    Recovery: middleware.RecoveryConfig{\n        Enabled: true,\n    },\n    Logger: middleware.LoggerConfig{\n        Enabled: true,\n        SkipPaths: []string{\n            \"/health\",\n            \"/metrics\",\n            \"/docs\",\n        },\n    },\n    TraceID: middleware.TraceIDConfig{\n        Enabled:    true,\n        HeaderName: \"X-Trace-ID\",\n    },\n}\n\nrouter.Setup(cfg)\n```\n\n## 常见问题\n\n### Q: 如何跳过某些路径的中间件？\n\nA: 在中间件中检查路径：\n\n```go\nfunc Logger(cfg LoggerConfig, log logger.Logger) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        if shouldSkip(c.Request.URL.Path, cfg.SkipPaths) {\n            c.Next()\n            return\n        }\n        // 处理日志\n    }\n}\n```\n\n### Q: 如何在中间件中访问请求体？\n\nA: 使用 `c.GetRawData()` 或 `c.ShouldBindJSON()`：\n\n```go\nfunc CustomMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // 读取请求体\n        body, err := c.GetRawData()\n        if err != nil {\n            c.Next()\n            return\n        }\n        \n        // 恢复请求体\n        c.Request.Body = io.NopCloser(bytes.NewBuffer(body))\n        \n        c.Next()\n    }\n}\n```\n\n### Q: 如何在中间件中修改响应？\n\nA: 使用 `gin.ResponseWriter` 包装器：\n\n```go\nfunc CustomMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // 包装响应写入器\n        writer := &responseWriter{ResponseWriter: c.Writer}\n        c.Writer = writer\n        \n        c.Next()\n        \n        // 访问响应数据\n        // writer.body\n    }\n}\n```\n\n---\n\n**最后更新**: 2025-12-30\n