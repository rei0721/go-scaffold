### 核心资产：`PROJECT_MEM.md` (项目记忆体)

请在项目根目录建立此文件。它是项目的“大脑”。不要只把它当做 Readme，它是给 AI 看的**动态约束文档**。

````markdown
# PROJECT MEMORY: [项目名称]

> **注意**：此文档是项目的唯一真理来源 (Single Source of Truth)。在编写代码前，必须优先阅读并更新此文档。

## 1. 核心上下文 (Context)

- **项目目标**: [一句话描述，例如：构建一个高并发的 Go 语言日志收集 CLI]
- **当前阶段**: [例如：Phase 1 - 原型验证 / Phase 2 - 数据库接入]
- **设计哲学**: [例如：优先使用标准库，减少第三方依赖 / 必须遵循 DDD 分层架构]

## 2. 技术栈与规范 (Tech Stack & Rules)

- **语言/版本**: [e.g., Go 1.23]
- **核心框架**: [e.g., Cobra, Gin, GORM]
- **代码规范**:
  - [ ] 所有的 Public 函数必须包含 GoDoc 注释。
  - [ ] 错误必须被 wrap，不能直接吞掉。
  - [ ] 配置文件使用 YAML 格式。

## 3. 动态领域词典 (Domain Glossary)

_在此处定义项目特有的关键词，供 AI 检索联想_

- **TaskNode**: 指代任务执行的最小单元，包含 ID 和 Status。
- **Pipeline**: 指代一组 TaskNode 的串行集合。
- **Store**: 指代持久化层，目前仅支持 SQLite。

## 4. 架构快照 (Architecture Snapshot)

_每次新增文件必须同步更新此处_

```text
/cmd          # 入口
/internal
  /domain     # 核心业务逻辑 (纯 Go 代码)
  /infra      # 数据库与外部接口实现
  /app        # 应用层编排
/pkg          # 通用工具
PROJECT_MEM.md
```
````

## 5. 待办与进度 (Backlog)

- [x] 初始化项目目录与 Go Mod
- [ ] **[当前聚焦]** 设计 `TaskNode` 的数据结构
- [ ] 实现 `Store` 接口

---

### 交互协议：思维触发器 (The Cognitive Trigger)

这是你每次发给 AI 的**通用 Prompt**。它强制 AI 在写代码前，先进行“关键词检索与细想”。

**复制以下内容作为每次对话的开场或预设指令：**

> **[系统指令：文档驱动开发模式]**
> 我将要求你执行一个开发任务。在输出任何代码之前，你必须严格执行以下 **<思维推演>** 步骤，并将其显式地输出在回复的开头：
> **步骤 1: 关键词检索 (Keyword Retrieval)**
>
> - 从我的请求和 `PROJECT_MEM.md` 中提取 3-5 个核心关键词（实体、技术组件、业务概念）。
>
> **步骤 2: 深度联想与约束检查 (Deep Reflection)**
>
> - 针对每个关键词，进行“记忆展开”：
> - _它在项目目录中的位置在哪里？_
> - _它关联了哪些技术规范（如错误处理、命名风格）？_
> - _它与现有的哪个模块（如 Database, Config）存在依赖关系？_
>
> - **关键检查**：我的请求是否违背了“设计哲学”？如果是，请立刻指出。
>
> **步骤 3: 伪代码/文档预演 (Doc Pre-flight)**
>
> - 不要直接写代码。先用伪代码或接口定义描述你的改动。
>
> **步骤 4: 最终实现 (Implementation)**
>
> - 确认无误后，生成最终代码。
>
> ---
>
> **我的请求是**：
> [在此处输入你的需求，例如：我要增加一个从配置文件读取数据库链接的功能]

---

### 一步一步演变流程 (Evolution Workflow)

如何使用这套工具从 0 到 1 开发？

#### 第一阶段：文档先行 (Definition Phase)

1. **动作**：创建空文件夹，仅创建 `PROJECT_MEM.md`。
2. **内容**：填写 `1. 核心上下文` 和 `2. 技术栈`。
3. **Prompt**：

   > "这是项目的核心记忆文件。基于此，请帮我规划 `4. 架构快照` 的目录结构。不要写代码，只更新文档。"

4. **结果**：你得到了一个完美的目录结构，**先更新到文档中**。

#### 第二阶段：核心对象定义 (Modeling Phase)

1. **动作**：更新 `PROJECT_MEM.md` 的 `5. 待办`，选中“设计 TaskNode 数据结构”。
2. **Prompt**：

   > "请根据架构快照，在 `internal/domain` 下设计 `TaskNode` 的结构体。**执行思维推演**，思考它需要哪些字段才能满足‘高并发日志收集’的目标？"

3. **AI 模拟检索**：

- _关键词_：`TaskNode`, `高并发`.
- _细想_：高并发意味着可能需要 `Mutex` 或 `Atomic` 状态；日志收集意味着需要 `Timestamp` 和 `Payload`。

4. **结果**：AI 生成结构体代码。**你先不急着粘贴代码，先检查逻辑，确认后将新文件路径更新回文档。**

#### 第三阶段：实现与迭代 (Implementation Loop)

这是日常开发的标准循环：

1. **更新文档**：在 `PROJECT_MEM.md` 记录你要做的功能（如：实现数据库保存）。
2. **发送指令**：使用【交互协议】Prompt。

- _User_: "实现 SQLite 的保存逻辑。"

3. **AI 思维推演 (Example Output)**：

- **关键词**: `SQLite`, `Store`, `infra层`.
- **深度联想**:
- `SQLite`: 技术栈里提到了 GORM 吗？(查看文档 -> 确认使用)。
- `infra层`: 代码应该放在 `/internal/infra` 目录下，不能污染 `domain` 层。
- `Store`: 需要实现 domain 层定义的接口。

- **计划**: 在 `infra` 包下创建 `sqlite_repo.go`，实现 `Save` 方法。

4. **生成代码**：AI 输出符合规范的代码。
5. **回写**：更新 `PROJECT_MEM.md` 的文件列表和 Decision Log（如果做了重大技术选型）。

---

### 为什么这样做有效？

1. **模拟人类专家的直觉**：专家写代码前，脑子里会先过一遍“这行代码放在哪？以前是怎么规定的？会影响什么？”。这套模板强制 AI 显式地做这件事。
2. **解决 AI 健忘**：AI 记不住你 10 轮对话前说的“变量要用蛇形命名法”，但如果这写在 `PROJECT_MEM.md` 里，并强制它每次检索，它就不会错。
3. **文档即代码**：你的文档不再是废纸，它是生成代码的**蓝图 (Blueprint)**。
