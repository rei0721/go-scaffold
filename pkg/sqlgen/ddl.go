package sqlgen

import (
	"fmt"
	"path/filepath"
	"strings"
)

// DDLGenerator SQL DDL 语句生成器
type DDLGenerator struct {
	config *Config
	writer FileWriter
}

// NewDDLGenerator 创建 DDL 生成器
func NewDDLGenerator(config *Config) *DDLGenerator {
	return &DDLGenerator{
		config: config,
		writer: NewFileWriter(),
	}
}

// GenerateDDL 生成 DDL 语句
func (g *DDLGenerator) GenerateDDL(schema *Schema) (string, error) {
	var builder strings.Builder

	// 文件头注释
	builder.WriteString("-- " + strings.Repeat("=", 60) + "\n")
	builder.WriteString(fmt.Sprintf("-- Database: %s\n", schema.Name))
	builder.WriteString(fmt.Sprintf("-- Generated by: sqlgen\n"))
	builder.WriteString(fmt.Sprintf("-- Database Type: %s\n", schema.DatabaseType))
	builder.WriteString("-- " + strings.Repeat("=", 60) + "\n\n")

	// 生成每个表的 DDL
	for i, table := range schema.Tables {
		if i > 0 {
			builder.WriteString("\n")
		}

		ddl, err := g.generateTableDDL(table, schema.DatabaseType)
		if err != nil {
			return "", err
		}
		builder.WriteString(ddl)

		// 生成索引 DDL
		indexDDL := g.generateIndexDDL(table, schema.DatabaseType)
		if indexDDL != "" {
			builder.WriteString("\n")
			builder.WriteString(indexDDL)
		}
	}

	return builder.String(), nil
}

// GenerateDDLToFile 生成 DDL 到文件
func (g *DDLGenerator) GenerateDDLToFile(schema *Schema, outputPath string) error {
	ddl, err := g.GenerateDDL(schema)
	if err != nil {
		return err
	}

	if outputPath == "" {
		outputPath = filepath.Join(g.config.OutputDir, "schema.sql")
	}

	return g.writer.WriteAtomic(outputPath, []byte(ddl))
}

// generateTableDDL 生成单个表的 CREATE TABLE 语句
func (g *DDLGenerator) generateTableDDL(table *Table, dbType DatabaseType) (string, error) {
	var builder strings.Builder

	// 表注释
	if table.Comment != "" {
		builder.WriteString(fmt.Sprintf("-- %s\n", table.Comment))
	}

	builder.WriteString(fmt.Sprintf("CREATE TABLE %s (\n", g.quoteIdentifier(table.Name, dbType)))

	// 字段定义
	var columnDefs []string
	for _, col := range table.Columns {
		colDef := g.generateColumnDef(col, dbType)
		columnDefs = append(columnDefs, "    "+colDef)
	}

	// 主键约束
	if len(table.PrimaryKey) > 0 && !g.hasSinglePKColumn(table) {
		pkDef := fmt.Sprintf("    PRIMARY KEY (%s)", strings.Join(table.PrimaryKey, ", "))
		columnDefs = append(columnDefs, pkDef)
	}

	// 外键约束
	for _, fk := range table.ForeignKeys {
		fkDef := g.generateForeignKeyDef(fk, dbType)
		columnDefs = append(columnDefs, "    "+fkDef)
	}

	builder.WriteString(strings.Join(columnDefs, ",\n"))
	builder.WriteString("\n)")

	// 表选项
	if dbType == DatabaseMySQL {
		builder.WriteString(" ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci")
	}

	builder.WriteString(";\n")

	return builder.String(), nil
}

// generateColumnDef 生成字段定义
func (g *DDLGenerator) generateColumnDef(col *Column, dbType DatabaseType) string {
	var parts []string

	// 字段名
	parts = append(parts, g.quoteIdentifier(col.Name, dbType))

	// 数据类型
	dataType := g.mapGoTypeToSQL(col, dbType)
	parts = append(parts, dataType)

	// NOT NULL
	if !col.Nullable {
		parts = append(parts, "NOT NULL")
	}

	// 主键和自增
	if col.IsPrimaryKey && g.hasSinglePK(col) {
		if col.IsAutoIncrement {
			switch dbType {
			case DatabaseSQLite:
				parts = append(parts, "PRIMARY KEY AUTOINCREMENT")
			case DatabaseMySQL:
				parts = append(parts, "PRIMARY KEY AUTO_INCREMENT")
			case DatabasePostgres:
				// PostgreSQL 使用 SERIAL 类型处理自增
				parts[1] = "SERIAL PRIMARY KEY"
				parts = parts[:2]
			}
		} else {
			parts = append(parts, "PRIMARY KEY")
		}
	}

	// 唯一约束
	for _, idx := range g.findUniqueIndexForColumn(col.Name) {
		if idx.IsUnique && len(idx.Columns) == 1 {
			parts = append(parts, "UNIQUE")
			break
		}
	}

	// 默认值
	if col.DefaultValue != nil {
		parts = append(parts, "DEFAULT "+*col.DefaultValue)
	}

	// 字段注释 (仅 MySQL 支持内联注释)
	if col.Comment != "" && dbType == DatabaseMySQL {
		parts = append(parts, fmt.Sprintf("COMMENT '%s'", escapeString(col.Comment)))
	}

	return strings.Join(parts, " ")
}

// generateIndexDDL 生成索引 DDL
func (g *DDLGenerator) generateIndexDDL(table *Table, dbType DatabaseType) string {
	var builder strings.Builder

	for _, idx := range table.Indexes {
		// 跳过主键索引 (已经在表定义中)
		if idx.IsPrimary {
			continue
		}

		var indexType string
		if idx.IsUnique {
			indexType = "UNIQUE INDEX"
		} else {
			indexType = "INDEX"
		}

		columns := strings.Join(idx.Columns, ", ")
		builder.WriteString(fmt.Sprintf("CREATE %s %s ON %s (%s);\n",
			indexType,
			g.quoteIdentifier(idx.Name, dbType),
			g.quoteIdentifier(table.Name, dbType),
			columns,
		))
	}

	return builder.String()
}

// generateForeignKeyDef 生成外键定义
func (g *DDLGenerator) generateForeignKeyDef(fk *ForeignKey, dbType DatabaseType) string {
	var builder strings.Builder

	builder.WriteString(fmt.Sprintf("CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s(%s)",
		g.quoteIdentifier(fk.Name, dbType),
		g.quoteIdentifier(fk.Column, dbType),
		g.quoteIdentifier(fk.RefTable, dbType),
		g.quoteIdentifier(fk.RefColumn, dbType),
	))

	if fk.OnDelete != "" {
		builder.WriteString(" ON DELETE " + fk.OnDelete)
	}
	if fk.OnUpdate != "" {
		builder.WriteString(" ON UPDATE " + fk.OnUpdate)
	}

	return builder.String()
}

// mapGoTypeToSQL Go 类型转 SQL 类型
func (g *DDLGenerator) mapGoTypeToSQL(col *Column, dbType DatabaseType) string {
	// 如果有原始数据类型，优先使用
	if col.DataType != "" {
		return col.DataType
	}

	// 根据 Go 类型推断 SQL 类型
	goType := strings.TrimPrefix(col.GoType, "*")

	switch goType {
	case "int", "int32":
		return "INTEGER"
	case "int64":
		if dbType == DatabasePostgres {
			return "BIGINT"
		}
		return "BIGINT"
	case "string":
		if col.Length > 0 {
			return fmt.Sprintf("VARCHAR(%d)", col.Length)
		}
		return "VARCHAR(255)"
	case "bool":
		if dbType == DatabasePostgres {
			return "BOOLEAN"
		}
		return "TINYINT(1)"
	case "float32":
		return "FLOAT"
	case "float64":
		return "DOUBLE"
	case "time.Time":
		return "TIMESTAMP"
	case "[]byte":
		return "BLOB"
	default:
		return "TEXT"
	}
}

// quoteIdentifier 引用标识符
func (g *DDLGenerator) quoteIdentifier(name string, dbType DatabaseType) string {
	switch dbType {
	case DatabaseMySQL:
		return "`" + name + "`"
	case DatabasePostgres:
		return `"` + name + `"`
	default:
		return name
	}
}

// hasSinglePKColumn 表是否只有一个主键字段
func (g *DDLGenerator) hasSinglePKColumn(table *Table) bool {
	pkCount := 0
	for _, col := range table.Columns {
		if col.IsPrimaryKey {
			pkCount++
		}
	}
	return pkCount == 1
}

// hasSinglePK 字段是否是唯一主键
func (g *DDLGenerator) hasSinglePK(col *Column) bool {
	return col.IsPrimaryKey
}

// findUniqueIndexForColumn 查找字段对应的唯一索引
func (g *DDLGenerator) findUniqueIndexForColumn(colName string) []*Index {
	return nil // 简化实现
}

// escapeString 转义字符串
func escapeString(s string) string {
	return strings.ReplaceAll(s, "'", "''")
}
